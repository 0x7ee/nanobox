diff --git a/commands/deploy.go b/commands/deploy.go
index 1f0884e..761aba6 100644
--- a/commands/deploy.go
+++ b/commands/deploy.go
@@ -9,6 +9,7 @@ package commands
 
 import (
 	"encoding/json"
+	"flag"
 	"fmt"
 	"os"
 
@@ -28,6 +29,14 @@ type (
 		ID     string `json:"id"`
 		Status string `json:"status"`
 	}
+
+	Entry struct {
+		Action string `json:"action"`
+		Document string `json:"document"`
+		Log string `json:"log"`
+		Model string `json:"model"`
+		Time string `json:"time"`
+	}
 )
 
 // Help prints detailed help text for the app list command
@@ -44,6 +53,24 @@ Usage:
 // Run displays select information about all of a user's apps
 func (c *DeployCommand) Run(opts []string) {
 
+	// flags
+	flags := flag.NewFlagSet("flags", flag.ContinueOnError)
+	flags.Usage = func() { c.Help() }
+
+	var fVerbose bool
+	flags.BoolVar(&fVerbose, "v", false, "")
+	flags.BoolVar(&fVerbose, "verbose", false, "")
+
+	if err := flags.Parse(opts); err != nil {
+		ui.LogFatal("[commands.destroy] flags.Parse() failed", err)
+	}
+
+	logLevel := "info"
+
+	if fVerbose {
+		logLevel = "debug"
+	}
+
 	// start the vm if it's not already running
 	// resume := ResumeCommand{}
 	// resume.Run(opts)
@@ -56,7 +83,8 @@ func (c *DeployCommand) Run(opts []string) {
 
 	defer client.Close()
 
-	sub, err := client.Subscribe([]string{"sync", "deploy"})
+	//
+	sub, err := client.Subscribe([]string{"sync", "deploy", logLevel})
 	if err != nil {
 		config.Console.Warn("Failed to subscribe to 'mist' updates... %v", err)
 	}
@@ -71,10 +99,13 @@ func (c *DeployCommand) Run(opts []string) {
 	// listen for messages coming from mist
 	for msg := range client.Data {
 
-		data := make(map[string]string)
+		entry := &Entry{}
+
+		fmt.Printf("READING THINGS!!! %q\n", msg.Data)
 
 		//
-		if err := json.Unmarshal([]byte(msg.Data), &data); err != nil {
+		if err := json.Unmarshal([]byte(msg.Data), &entry); err != nil {
+			fmt.Println("FAIL 1")
 			ui.LogFatal("[commands deploy] json.Unmarshal() failed ", err)
 		}
 
@@ -82,27 +113,30 @@ func (c *DeployCommand) Run(opts []string) {
 		switch {
 
 		// if the message contains the log field, the log is printed...
-		case data["log"] != "":
-			entry := fmt.Sprintf("[%v] %v", data["log"], data["time"])
-
-			fmt.Println(entry)
+		case entry.Log != "":
+			fmt.Println(fmt.Sprintf("[%v] %v", entry.Log, entry.Time))
 
 		// if the message contains the model field, handle individually
-		case data["model"] != "":
+		case entry.Model != "":
 
 			// depending on the type of model, different things may happen...
-			switch data["model"] {
+			switch entry.Model {
 
 			// in the case of a sync model, listen for a complete to close the stream
-			case "sync":
+			case "Sync", "sync":
+
 				sync := &Sync{}
 
-				if err := json.Unmarshal([]byte(data["document"]), sync); err != nil {
+				if err := json.Unmarshal([]byte(entry.Document), sync); err != nil {
+					fmt.Println("FAIL 2")
 					ui.LogFatal("[commands deploy] json.Unmarshal() failed ", err)
 				}
 
+				fmt.Println("STATUS?", sync.Status)
+
 				// once the sync is 'complete' unsubscribe from mist, and close the connection
 				if sync.Status == "complete" {
+					fmt.Println("CLOSING?")
 					client.Unsubscribe(sub)
 					client.Close()
 				}
@@ -111,7 +145,7 @@ func (c *DeployCommand) Run(opts []string) {
 			// else should fail because logic is probably missing to handle the new
 			// model
 			case "default":
-				config.Console.Error("[commands deploy] Unhandled model '%v'", data["model"])
+				config.Console.Error("[commands deploy] Unhandled model '%v'", entry.Model)
 				os.Exit(1)
 			}
 
@@ -119,7 +153,7 @@ func (c *DeployCommand) Run(opts []string) {
 		// needs to fail, because it's probably missing some logic to handle a new
 		// field
 		default:
-			config.Console.Error("[commands deploy] Unhandled data, missing 'log' or 'model': %v", data)
+			config.Console.Error("[commands deploy] Unhandled data, missing 'log' or 'model': %v", entry)
 			os.Exit(1)
 		}
 	}
diff --git a/commands/destroy.go b/commands/destroy.go
index a590c50..6ef703d 100644
--- a/commands/destroy.go
+++ b/commands/destroy.go
@@ -52,6 +52,51 @@ func (c *DestroyCommand) Run(opts []string) {
 		ui.LogFatal("[commands.destroy] flags.Parse() failed", err)
 	}
 
+	// if force is not passed, confirm the decision to delete...
+	if !fForce {
+		config.Console.Warn("[commands.destroy.Run] Issuing confirm delete.")
+
+		switch ui.Prompt("Are you sure you want to delete this VM (y/N)? ") {
+
+		// proceed to destroy the VM...
+		case "Y", "y":
+			config.Console.Warn("Delete request confirmed, deleting...")
+			destroy()
+
+		// exit w/o destroying the VM...
+		default:
+			config.Console.Warn("Delete request refuted, VM will not be deleted...")
+			os.Exit(0)
+		}
+	}
+
+	// if force is passed, destroy...
+	config.Console.Warn("[commands.destroy.Run] Issuing force delete.")
+	destroy()
+}
+
+// destroy
+func destroy() {
+
+	// remove app
+	if err := os.RemoveAll(config.AppDir); err != nil {
+		ui.LogFatal("[commands.destroy] os.RemoveAll() failed", err)
+	}
+
+	// remove entry
+	removeEntry()
+
+	// destroy the vm...
+	cmd := &exec.Cmd{}
+	cmd = exec.Command("vagrant", "destroy", "--force")
+	if err := runVagrantCommand(cmd); err != nil {
+		ui.LogFatal("[commands.destroy] runVagrantCommand() failed", err)
+	}
+}
+
+// removeEntry
+func removeEntry() {
+
 	// assume we wont need to remove an entry...
 	removeEntry := false
 
@@ -108,27 +153,4 @@ func (c *DestroyCommand) Run(opts []string) {
 			}
 		}
 	}
-
-	cmd := &exec.Cmd{}
-
-	// vagrant destroy
-	if fForce {
-		config.Console.Warn("[commands.destroy.Run] Issuing force delete.")
-		cmd = exec.Command("vagrant", "destroy", "--force")
-
-		//
-	} else {
-		config.Console.Warn("[commands.destroy.Run] Issuing confirm delete.")
-		cmd = exec.Command("vagrant", "destroy")
-	}
-
-	// destroy the vm...
-	if err := runVagrantCommand(cmd); err != nil {
-		ui.LogFatal("[commands.destroy] runVagrantCommand() failed", err)
-	}
-
-	// destroy the project folder in /.nanobox with the Vagrantfile and .vagrant folder
-	if err := os.RemoveAll(config.AppDir); err != nil {
-		ui.LogFatal("[commands.destroy] os.RemoveAll() failed", err)
-	}
 }
diff --git a/commands/domain.go b/commands/domain.go
index e942252..8ebed49 100644
--- a/commands/domain.go
+++ b/commands/domain.go
@@ -99,7 +99,7 @@ func (c *DomainCommand) Run(opts []string) {
 		config.Console.Info("Adding '%v' private network to hosts file...", config.App)
 
 		//
-		entry := fmt.Sprintf("%-15v   %s.%s # '%v' private network (added by nanobox)", config.Boxfile.IP, config.App, config.Boxfile.Domain, config.App)
+		entry := fmt.Sprintf("\n%-15v   %s.%s # '%v' private network (added by nanobox)", config.Boxfile.IP, config.App, config.Boxfile.Domain, config.App)
 
 		// write the entry to the hosts file
 		if _, err := f.WriteString(entry); err != nil {
diff --git a/commands/fetch.go b/commands/fetch.go
index cc5f83a..d943034 100644
--- a/commands/fetch.go
+++ b/commands/fetch.go
@@ -95,7 +95,7 @@ func (c *FetchCommand) Run(opts []string) {
 	}
 
 	//
-	e, err := api.GetEngine(engine)
+	e, err := api.GetEngine(api.UserSlug, engine)
 	if err != nil {
 		fmt.Println("ERR!!", err)
 		config.Console.Info("No engines found on nanobox by the name '%v'", engine)
@@ -107,8 +107,13 @@ func (c *FetchCommand) Run(opts []string) {
 		version = match[2]
 	}
 
-	//
-	path := fmt.Sprintf("http://warehouse.nanobox.io/objects/release-%v", version)
+	// pull directly from warehouse
+	path := fmt.Sprintf("http://warehouse.nanobox.io/objects/releases/%v", version)
+
+	// pull from odin
+	// path := fmt.Sprintf("http://api.nanobox.io/v1/engines/%v/%v/releases/%v/download", api.UserSlug, e.Name, version)
+
+	fmt.Println("FETCH!", path)
 
 	//
 	out, err := os.Create("release.tgz")
@@ -122,15 +127,22 @@ func (c *FetchCommand) Run(opts []string) {
 		"Userid":      e.WarehouseUser,
 		"Key":         e.WarehouseKey,
 		"Bucketid":    e.ID,
-		"Objectalias": "release-" + version,
+		"Objectalias": "releases/" + version,
 	}
 
+	fmt.Printf("HEADERS! %#v\n", headers)
+
 	//
 	req, err := api.NewRequest("GET", path, nil, headers)
 	if err != nil {
 		ui.LogFatal("[commands.publish] api.DoRawRequest() failed", err)
 	}
 
+	// req, err := api.NewRequest("GET", path, nil, nil)
+	// if err != nil {
+	// 	ui.LogFatal("[commands.publish] api.DoRawRequest() failed", err)
+	// }
+
 	//
 	res, err := api.HTTPClient.Do(req)
 	if err != nil {
@@ -138,6 +150,8 @@ func (c *FetchCommand) Run(opts []string) {
 	}
 	defer res.Body.Close()
 
+	fmt.Println("RESPONSE!!", res)
+
 	//
 	if _, err := io.Copy(out, res.Body); err != nil {
 		ui.LogFatal("[commands.publish] io.Copy() failed", err)
diff --git a/commands/init.go b/commands/init.go
index e8e30d6..68ef28d 100644
--- a/commands/init.go
+++ b/commands/init.go
@@ -139,7 +139,7 @@ Vagrant.configure(2) do |config|
 
 
     ## box
-    nanobox.vm.box_url = "https://github.com/pagodabox/nanobox-boot2docker/releases/download/v0.0.6/nanobox-boot2docker.box"
+    nanobox.vm.box_url = "https://github.com/pagodabox/nanobox-boot2docker/releases/download/v0.0.7/nanobox-boot2docker.box"
     nanobox.vm.box     = "nanobox/boot2docker"
 
 
diff --git a/commands/log.go b/commands/log.go
index 7dae317..26ff60c 100644
--- a/commands/log.go
+++ b/commands/log.go
@@ -8,41 +8,244 @@
 package commands
 
 import (
-	// "fmt"
+  "encoding/json"
+  "flag"
+  "fmt"
+  "regexp"
+  // "sort"
+  // "strconv"
+  "time"
 
-	// api "github.com/pagodabox/nanobox-api-client"
-	// "github.com/pagodabox/nanobox-cli/config"
-	"github.com/pagodabox/nanobox-cli/ui"
+  mist "github.com/pagodabox/golang-mist"
+  "github.com/pagodabox/nanobox-cli/config"
+  "github.com/pagodabox/nanobox-cli/ui"
 )
 
-// LogCommand satisfies the Command interface for listing a user's apps
-type LogCommand struct{}
+type (
 
-// Help prints detailed help text for the app list command
+  // LogCommand satisfies the Command interface for obtaining an app's historical
+  // and streaming logs
+  LogCommand struct{}
+
+  // Logs represents a slice of Log's
+  Logs []Log
+
+  // Log represents the structure of a log returned from Logvac or Stormpack
+  Log struct {
+    Log  string `json:"log"`
+    Time int    `json:"time"`
+  }
+)
+
+// a map of each type of 'process' that we encounter to then be used when assigning
+// a unique color to that 'process'
+var logProcesses = make(map[string]string)
+
+// an array of the colors used to colorize the logs
+var logColors = [11]string{
+  // "red",
+  "green",
+  "yellow",
+  "blue",
+  "magenta",
+  "cyan",
+  // "light_red", // this is reserved for a failover output
+  "light_green",
+  "light_yellow",
+  "light_blue",
+  "light_magenta",
+  "light_cyan",
+  "white",
+}
+
+// functions for sorting logs by timestamp
+func (l Logs) Len() int {
+  return len(l)
+}
+
+func (l Logs) Less(i, j int) bool {
+  return l[i].Time < l[j].Time
+}
+
+func (l Logs) Swap(i, j int) {
+  l[i], l[j] = l[j], l[i]
+}
+
+// Help prints detailed help text for the app log command
 func (c *LogCommand) Help() {
-	ui.CPrint(`
+  ui.CPrint(`
 Description:
-  Show/Stream nanobox logs
+  Provides log output for an application.
+
+  If [app-name] is not provided, will attempt to detect [app-name] from git
+  remotes. If no app or multiple apps detected, will prompt for [app-name].
 
   If [count] is not provided, will show the last 100 lines of the log.
 
   If [live] is not provided, will default to showing the last 100 lines.
 
 Usage:
-  nanobox log [-c count] [-l]
+  pagoda log [-a app-name] [-c count] [-l]
+  pagoda app:log [-a app-name] [-c count] [-l]
 
-  ex. nanobox log -c 100 -l
+  ex. pagoda log -a app-name -c 100 -l
 
 Options:
+  -a, --app [app-name]
+    The name of the app you want to view logs for.
+
   -c, --count [count]
     The number of lines of the log you wish to view.
 
   -l, --live
     Enable live stream
+    // emergency, alert, critical, error, warning, notice, informational, debug, log
+
+  --level
+    Log level
   `)
 }
 
-// Run displays select information about all of a user's apps
+// Run attempts to display an app's logs. It takes count flag to designate how
+// many logs to print, and a stream flag to indicate the live stream rather than
+// historical. Logs are prased, colorized and printed to the terminal
 func (c *LogCommand) Run(opts []string) {
 
+  // flags
+  flags := flag.NewFlagSet("flags", flag.ContinueOnError)
+  flags.Usage = func() { c.Help() }
+
+  var fCount int
+  flags.IntVar(&fCount, "c", 100, "")
+  flags.IntVar(&fCount, "count", 100, "")
+
+  var fStream bool
+  flags.BoolVar(&fStream, "l", false, "")
+  flags.BoolVar(&fStream, "live", false, "")
+
+  var fLevel string
+  flags.StringVar(&fLevel, "level", "info", "")
+
+  if err := flags.Parse(opts); err != nil {
+    ui.LogFatal("[commands.app_log] flags.Parse()", err)
+  }
+
+  // if stream is true, we connect to the live logs
+  if fStream {
+
+    // connect websocket
+    fmt.Println("Connecting to live stream...")
+
+    // subscribe to mist
+    client := mist.Client{}
+    if _, err := client.Connect(config.Boxfile.IP, "1445"); err != nil {
+      ui.LogFatal("[commands deploy] client.Connect() failed ", err)
+    }
+
+    defer client.Close()
+
+    //
+    sub, err := client.Subscribe([]string{"app", fLevel})
+    if err != nil {
+      config.Console.Warn("Failed to subscribe to 'mist' updates... %v", err)
+    }
+
+    //
+    config.Console.Debug("[commands.app_log.Run] Subscribing to logs: %#v", sub)
+
+    //
+    var log Log
+
+    //
+    fmt.Println("Waiting for data...")
+
+    //
+    for msg := range client.Data {
+
+      data := make(map[string]string)
+
+      if data["log"] != "" {
+
+        //
+        if err := json.Unmarshal([]byte(msg.Data), &log); err != nil {
+          ui.LogFatal("[commands.app_log] json.Unmarshal() failed", err)
+        }
+
+        processLog(log)
+      }
+    }
+
+    // load historical logs
+  } else {
+
+    // logsURL := fmt.Sprintf("https://log.pagodabox.io/app/%v?limit=%v", safeID, strconv.Itoa(fCount))
+
+    // //
+    // config.Console.Debug("[commands.app_log.Run] Requesting historical logs from: %v", logsURL)
+
+    // // request historical logs
+    // if err := api.DoRawRequest(&logvac.Logs, "GET", logsURL, nil, map[string]string{"X-AUTH-TOKEN": logvac.Token}); err != nil {
+    //   ui.LogFatal("[commands.app_log] api.DoRawRequest() failed", err)
+    // }
+
+    // // sort logs
+    // sort.Sort(logvac.Logs)
+
+    // ui.CPrint("[yellow]Showing last %v log entries...[reset]", strconv.Itoa(fCount))
+
+    // // display logs
+    // for _, log := range logvac.Logs {
+    //   processLog(log)
+    // }
+
+  }
+}
+
+// processLog takes a Logvac or Stormpack log and breaks it apart into pieces that
+// are then reconstructed in a 'digestible' way, colorized, and output to the
+// terminal
+func processLog(log Log) {
+
+  time := time.Unix(0, int64(log.Time)*1000).Format(time.RFC822)
+
+  //
+  reFindLog := regexp.MustCompile(`^(\w+)\.(\S+)\s+(.*)$`)
+
+  // example data stream parsed with regex
+  // log.Log  = web1.apache[access] 69.92.84.90 - - [03/Dec/2013:19:59:57 +0000] \"GET / HTTP/1.1\" 200 183 \"-\" \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_9_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/31.0.1650.57 Safari/537.36\"\n"
+  // subMatch[1] = web1
+  // subMatch[2] = apache[access]
+  // subMatch[3] = 69.92.84.90 - - [03/Dec/2013:19:59:57 +0000] \"GET / HTTP/1.1\" 200 183 \"-\" \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_9_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/31.0.1650.57 Safari/537.36\"\n"
+
+  //
+  config.Console.Debug("[commands.app_log.processLog] Raw log -> %#v", log)
+
+  subMatch := reFindLog.FindStringSubmatch(log.Log)
+
+  // ensure a subMatch and ensure subMatch has a length of 4, since thats how many
+  // matches we're expecting
+  if subMatch != nil && len(subMatch) >= 4 {
+
+    service := subMatch[1]
+    process := subMatch[2]
+    entry := subMatch[3]
+
+    //
+    config.Console.Debug("[commands.app_log.processLog] Processed log -> service: %v, process: %v, entry: %v\n", service, process, entry)
+
+    if _, ok := logProcesses[process]; !ok {
+      logProcesses[process] = logColors[len(logProcesses)%len(logColors)]
+    }
+
+    ui.CPrint("[%v]%v - %v.%v :: %v[reset]", logProcesses[process], time, service, process, entry)
+
+    // if we don't have a subMatch or its length is less than 4, just print w/e
+    // is in the log
+  } else {
+    //
+    config.Console.Debug("[commands.app_log.processLog] No submatches found -> %v - %v", time, log.Log)
+
+    ui.CPrint("[light_red]%v - %v[reset]", time, log.Log)
+  }
+
 }
diff --git a/commands/publish.go b/commands/publish.go
index a116370..f4f29ab 100644
--- a/commands/publish.go
+++ b/commands/publish.go
@@ -92,7 +92,7 @@ func (c *PublishCommand) Run(opts []string) {
 	}
 
 	// look for a Enginefile to parse
-	enginefile, err := os.Stat("./Enginefile")
+	fi, err := os.Stat("./Enginefile")
 	if err != nil {
 		fmt.Println("Enginefile not found. Be sure to publish from a project directory. Exiting... ")
 		config.Log.Fatal("[commands.publish] os.Stat() failed", err)
@@ -100,7 +100,7 @@ func (c *PublishCommand) Run(opts []string) {
 	}
 
 	//
-	file, err := ioutil.ReadFile(enginefile.Name())
+	file, err := ioutil.ReadFile(fi.Name())
 	if err != nil {
 		ui.LogFatal("[commands.publish] ioutil.ReadFile() failed", err)
 	}
@@ -119,10 +119,12 @@ func (c *PublishCommand) Run(opts []string) {
 
 	release.Readme = string(b)
 
+	// add Enginefile to the list of a releases project_files
+	release.ProjectFiles = append(release.ProjectFiles, "Enginefile")
+
 	// GET to API to see if engine exists
-	engine, err := api.GetEngine(release.Name)
+	engine, err := api.GetEngine(api.UserSlug, release.Name)
 	if err != nil {
-		fmt.Println("ERR!!!", err)
 		config.Console.Info("No engines found on nanobox by the name '%v'", release.Name)
 	}
 
@@ -139,7 +141,7 @@ func (c *PublishCommand) Run(opts []string) {
 		for {
 			fmt.Print(".")
 
-			p, err := api.GetEngine(release.Name)
+			p, err := api.GetEngine(api.UserSlug, release.Name)
 			if err != nil {
 				ui.LogFatal("[commands.publish] api.GetEngine() failed", err)
 			}
@@ -238,6 +240,9 @@ func (c *PublishCommand) Run(opts []string) {
 
 		release.Checksum = checksum
 
+		//
+		config.Console.Info("Publishing release to nanobox...")
+
 		// POST release on API (odin)
 		if _, err := api.CreateEngineRelease(engine.Name, release); err != nil {
 			ui.LogFatal("[commands.publish] api.CreateEngineRelease() failed", err)
diff --git a/commands/update.go b/commands/update.go
index dcae26a..263a67a 100644
--- a/commands/update.go
+++ b/commands/update.go
@@ -16,7 +16,7 @@ import (
 	"os"
 	"runtime"
 
-	"bitbucket.org/kardianos/osext"
+	"github.com/kardianos/osext"
 
 	"github.com/pagodabox/nanobox-cli/config"
 	"github.com/pagodabox/nanobox-cli/ui"
