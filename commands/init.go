// Copyright (c) 2015 Pagoda Box Inc
//
// This Source Code Form is subject to the terms of the Mozilla Public License, v.
// 2.0. If a copy of the MPL was not distributed with this file, You can obtain one
// at http://mozilla.org/MPL/2.0/.
//

package commands

import (
	"fmt"
	"io/ioutil"
	"os"
	"path/filepath"

	"github.com/pagodabox/nanobox-cli/config"
	"github.com/pagodabox/nanobox-cli/ui"
)

// InitCommand satisfies the Command interface
type InitCommand struct{}

// Help prints detailed help text for the app list command
func (c *InitCommand) Help() {
	ui.CPrint(`
Description:
  Creates a nanobox flavored Vagrantfile

Usage:
  nanobox init
  `)
}

// Run creates a Vagrantfile
func (c *InitCommand) Run(opts []string) {

	// creates a project folder in /.nanobox where the Vagrantfile and .vagrant dir
	// will live for each app
	if di, _ := os.Stat(config.AppDir); di == nil {

		//
		config.Console.Info("Creating project directory at: %v", config.AppDir)

		if err := os.Mkdir(config.AppDir, 0755); err != nil {
			fmt.Println("There was an error creating a project directory for '%v' at '%v'. Exiting... %v", config.App, config.AppDir, err)
			os.Exit(1)
		}
	}

	//
	// create synced folders

	//
	synced_folders := fmt.Sprintf("config.vm.synced_folder \"%v\", \"/vagrant/code/%v\"", config.CWDir, config.App)

	// if an engine path is provided, add it to the synced_folders
	if engine := config.Boxfile.Engine; engine != "" {
		if fi, _ := os.Stat(engine); fi != nil {
			fp, err := filepath.Abs(engine)
			if err != nil {
				ui.LogFatal("[commands.init] filepath.Abs() failed", err)
			}
			synced_folders += fmt.Sprintf("\n  config.vm.synced_folder \"%v\", \"/vagrant/engines/%v\"", fp, engine)
		} else {
			config.Console.Warn("Unable to mount '%v' (not a valid directory). Configuring as engine...", engine)
		}
	}

	// if a plugin path is provided, add it to the synced_folders
	if plugin := config.Boxfile.Plugin; plugin != "" {
		if fi, _ := os.Stat(plugin); fi != nil {
			fp, err := filepath.Abs(plugin)
			if err != nil {
				ui.LogFatal("[commands.init] filepath.Abs() failed", err)
			}
			synced_folders += fmt.Sprintf("\n  config.vm.synced_folder \"%v\", \"/vagrant/plugins/%v\"", fp, plugin)
		} else {
			config.Console.Warn("Unable to mount '%v' (not a valid directory). Configuring as plugin...", plugin)
		}
	}

	//
	// create nanobox private network
	config.Console.Info("Private network created ('%v')...", config.Boxfile.IP)
	network := fmt.Sprintf("config.vm.network \"private_network\", ip: \"%v\"", config.Boxfile.IP)

	//
	// configure provider

	config.Console.Info("Configuring detected 'provider' (%v)...", config.Boxfile.Provider)

	provider := ""

	//
	switch config.Boxfile.Provider {

	//
	case "virtualbox":
		provider = fmt.Sprintf(`
	# VirtualBox
	config.vm.provider "virtualbox" do |p|
		p.customize ["modifyvm", :id, "--cpuexecutioncap", "%v"]
		p.cpus = %v
		p.memory = %v
	end`, config.Boxfile.CPUCap, config.Boxfile.CPUs, config.Boxfile.RAM)

	//
	case "vmware":
		provider = fmt.Sprintf(`
  # VMWare
  config.vm.provider "vmware" do |p|
	  v.vmx["numvcpus"] = "%v"
	  v.vmx["memsize"] = "%v"
  end`, config.Boxfile.CPUCap, config.Boxfile.CPUs, config.Boxfile.RAM)
	}

	//
	// create Vagrantfile

	config.Console.Info("Generating Vagrantfile...")

	//
	vagrantfile := fmt.Sprintf(`
## This file was generated by nanobox ##

# -*- mode: ruby -*-
# vi: set ft=ruby :

Vagrant.configure(2) do |config|

  ## box
  config.vm.box_url = "https://github.com/pagodabox/nanobox-boot2docker/releases/download/v0.0.1/nanobox-boot2docker.box"
  config.vm.box     = "nanobox/boot2docker"


  ## network
  %s


  ## shared folders

  # disable default /vagrant share to override...
  config.vm.synced_folder ".", "/vagrant", disabled: true

  # ...add nanobox shared folders
  %s


  ## provider configs
  %s


  ##
  config.vm.post_up_message = "Nanobox is up and running!"

end
`, network, synced_folders, provider)

	// write the Vagrantfile
	if err := ioutil.WriteFile(config.AppDir+"/Vagrantfile", []byte(vagrantfile), 0755); err != nil {
		ui.LogFatal("[commands.init] ioutil.WriteFile() failed", err)
	}

}
